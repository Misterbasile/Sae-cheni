LIBRARY IEEE;
USE IEEE.STD_LOGIC_1164.ALL;
USE IEEE.STD_LOGIC_ARITH.ALL;
USE IEEE.STD_LOGIC_UNSIGNED.ALL;

ENTITY clock_divider IS
    PORT (
        CLOCK_50 : IN STD_LOGIC;        -- Horloge de base 50 MHz
        reset    : IN STD_LOGIC;        -- Réinitialisation
        speed    : IN STD_LOGIC_VECTOR(1 DOWNTO 0); -- Sélection vitesse (00 = 1Hz, 01 = 3Hz, 10 = 6Hz, 11 = 9Hz)
        clk_out  : OUT STD_LOGIC        -- Horloge divisée
    );
END ENTITY clock_divider;

ARCHITECTURE behavior OF clock_divider IS
    SIGNAL counter   : INTEGER := 0;
    SIGNAL clk_state : STD_LOGIC := '0';
    CONSTANT MAX_COUNT_1HZ : INTEGER := 50000000 / 2;
    CONSTANT MAX_COUNT_3HZ : INTEGER := 16666667 / 2;
    CONSTANT MAX_COUNT_6HZ : INTEGER := 8333333 / 2;
    CONSTANT MAX_COUNT_9HZ : INTEGER := 5555556 / 2;
    SIGNAL max_count : INTEGER := MAX_COUNT_1HZ; -- Par défaut à 1Hz

BEGIN

    -- Sélection de la fréquence en fonction de "speed"
    PROCESS (speed)
    BEGIN
        CASE speed IS
            WHEN "00" => max_count <= MAX_COUNT_1HZ; -- 1Hz
            WHEN "01" => max_count <= MAX_COUNT_3HZ; -- 3Hz
            WHEN "10" => max_count <= MAX_COUNT_6HZ; -- 6Hz
            WHEN "11" => max_count <= MAX_COUNT_9HZ; -- 9Hz
            WHEN OTHERS => max_count <= MAX_COUNT_1HZ;
        END CASE;
    END PROCESS;

    -- Processus pour diviser l'horloge
    PROCESS (CLOCK_50, reset)
    BEGIN
        IF reset = '1' THEN
            counter <= 0;
            clk_state <= '0';
        ELSIF rising_edge(CLOCK_50) THEN
            IF counter >= max_count THEN
                counter <= 0;
                clk_state <= NOT clk_state;
            ELSE
                counter <= counter + 1;
            END IF;
        END IF;
    END PROCESS;

    clk_out <= clk_state; -- Sortie horloge divisée

END ARCHITECTURE behavior;
